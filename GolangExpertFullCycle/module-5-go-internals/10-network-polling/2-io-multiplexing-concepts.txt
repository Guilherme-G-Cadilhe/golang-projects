=====================================
  CONCEITOS DE I/O MULTIPLEXING
=====================================
- I/O Multiplexing é a técnica que permite a um único processo ou thread monitorar múltiplos File Descriptors (FDs) simultaneamente, para descobrir quais estão prontos para uma operação (leitura ou escrita) sem precisar bloquear.

-------------------------------------
  O "PORQUÊ" DO I/O MULTIPLEXING
-------------------------------------
- O PROBLEMA: Um servidor de rede precisa lidar com milhares de clientes. Se o servidor usasse um modelo de uma thread por cliente, ele rapidamente esgotaria os recursos do sistema. Se usasse uma única thread com I/O bloqueante, um cliente lento travaria todos os outros.

- A SOLUÇÃO: Com I/O Multiplexing, uma única thread pode gerenciar todas as conexões. Ela pergunta ao Kernel: "Qual destes 10.000 clientes tem algo novo para mim?". O Kernel responde com uma lista apenas dos clientes prontos, e a thread processa somente eles, de forma eficiente.

- ANALOGIA: É como um recepcionista de hotel gerenciando um painel com 100 linhas telefônicas. Em vez de ficar com o ouvido em uma linha esperando tocar (bloqueio), ele olha para o painel de luzes. Apenas quando uma luz pisca (evento de I/O), ele atende aquela linha.

-------------------------------------
  OS "NOTIFICADORES" DO SISTEMA OPERACIONAL
-------------------------------------
- São as diferentes chamadas de sistema (syscalls) que implementam o I/O Multiplexing. O Go abstrai o uso delas, mas por baixo dos panos, está usando uma destas:

  * select: O mais antigo e portável, mas menos eficiente.
    - LIMITAÇÃO: Tem um limite máximo de FDs (geralmente 1024) e, a cada chamada, a aplicação precisa reenviar a lista inteira de FDs para o Kernel, que a percorre linearmente. Ineficiente para milhares de conexões.

  * poll: Uma evolução do `select`.
    - MELHORIA: Não tem o limite de 1024 FDs.
    - LIMITAÇÃO: Ainda sofre do mesmo problema de performance: a lista inteira de FDs é copiada entre a aplicação e o Kernel a cada chamada.

  * epoll (Linux): O padrão de alta performance no Linux.
    - A GRANDE MUDANÇA: O Kernel mantém a lista de FDs de interesse. A aplicação registra os FDs uma vez (`epoll_ctl`) e depois só pede ao Kernel por uma lista de FDs que ficaram prontos (`epoll_wait`). A cópia de dados é mínima. Escala para centenas de milhares de FDs.

  * kqueue (macOS/BSD): Similar em performance e conceito ao `epoll`.
    - VANTAGEM: É mais genérico, podendo monitorar outros eventos do sistema, como sinais e timers, não apenas I/O.

  * IOCP (Windows - I/O Completion Ports): Um modelo diferente.
    - COMO FUNCIONA: Em vez de perguntar "quem está pronto?", a aplicação diz ao Kernel "inicie esta operação de I/O para mim e me avise quando ela estiver **completa**". O SO gerencia um pool de threads e coloca os resultados das operações concluídas em uma fila, de onde a aplicação os retira.