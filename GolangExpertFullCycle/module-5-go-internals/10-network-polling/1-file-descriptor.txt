=====================================
  NETWORK POLLING: FILE DESCRIPTORS (FD)
=====================================
- Para entender como o Go lida com milhares de conexões de rede de forma eficiente, precisamos primeiro entender a abstração fundamental que os sistemas operacionais usam para I/O: o File Descriptor.

-------------------------------------
  O QUE É UM FILE DESCRIPTOR?
-------------------------------------
- É um número inteiro, positivo, que serve como um "identificador" ou uma "alça" para um recurso de I/O gerenciado pelo Kernel do sistema operacional.
- Em sistemas Unix-like (Linux, macOS), quase tudo é tratado como um arquivo: arquivos de texto, conexões de rede (sockets), pipes, periféricos, etc. O FD é a forma do seu programa se referir a esses recursos.
- ANALOGIA: Pense em uma senha de atendimento em um hospital. Você não diz "Eu sou o João da Silva com dor no joelho". Você diz "Minha senha é a 123". O sistema do hospital (o Kernel) sabe que a senha 123 (o FD) se refere a você (o recurso de I/O).

-------------------------------------
  FDs PADRÃO (STANDARD STREAMS)
-------------------------------------
- Todo processo em um sistema Unix-like começa com três FDs especiais já abertos:
  * `0`: stdin (entrada padrão, geralmente o teclado).
  * `1`: stdout (saída padrão, geralmente a tela do terminal).
  * `2`: stderr (saída de erro padrão, também a tela).

-------------------------------------
  O PADRÃO DE I/O NÃO-BLOQUEANTE (KERNEL E FD)
-------------------------------------
- Este fluxo é a base para a concorrência eficiente em Go e Node.js.

  1. APLICAÇÃO DIZ AO KERNEL: "Quero ler dados desta conexão de rede (socket)".
  2. KERNEL RESPONDE: "Ok, registrei seu interesse. O File Descriptor para esta conexão é o **FD 7**."
  3. KERNEL TRABALHA: O Kernel espera os dados chegarem da rede. Enquanto isso, a aplicação está **livre** para fazer outras coisas.
  4. DADOS CHEGAM: O Kernel recebe os dados e os armazena em um buffer interno. Ele então marca o **FD 7** como "pronto para leitura".
  5. KERNEL NOTIFICA: O Kernel avisa a aplicação que o FD 7 está pronto.
  6. APLICAÇÃO LÊ: A aplicação agora chama `read(FD 7)`, e os dados são copiados do buffer do Kernel para o buffer da aplicação, de forma imediata e sem bloqueio.

-------------------------------------
  MONITORAMENTO EFICIENTE: EPOLL, KQUEUE, IOCP
-------------------------------------
- Como uma aplicação monitora milhares de FDs para saber quais estão "prontos"? Chamar o Kernel para perguntar sobre cada um seria muito ineficiente.
- Para resolver isso, os sistemas operacionais modernos fornecem mecanismos de monitoramento de eventos de alta performance:
  * `epoll`: Em Linux. É o mais famoso.
  * `kqueue`: Em sistemas BSD (incluindo macOS).
  * `IOCP` (I/O Completion Ports): Em Windows.
- Esses mecanismos permitem que a aplicação diga ao Kernel: "Me avise quando QUALQUER UM destes 10.000 FDs estiver pronto". O Kernel faz o monitoramento de forma otimizada e só "acorda" a aplicação quando há trabalho a ser feito.

-------------------------------------
  A CONEXÃO COM GO: O NETWORK POLLER (NETPOLLER)
-------------------------------------
- O Netpoller do Go é uma abstração interna do runtime que utiliza `epoll`, `kqueue` ou `IOCP` por baixo dos panos. É ele que integra o I/O com o scheduler de goroutines.

- FLUXO DE UMA LEITURA DE REDE EM GO:
  1. Uma goroutine (G1) chama `conexao.Read()`.
  2. O Go Runtime vê que a operação seria bloqueante. Em vez de bloquear a thread, ele faz o seguinte:
  3. Ele passa o FD da conexão para o **Netpoller**.
  4. O Netpoller registra o FD no `epoll` do Kernel, pedindo para ser notificado quando houver dados para ler.
  5. A goroutine G1 é colocada no estado de **espera** ("parked") e **sai da thread do SO (M)**.
  6. A thread (M) fica imediatamente livre para executar **outra goroutine** (G2) da fila.
  7. Quando os dados chegam na rede, o Kernel notifica o `epoll`, que por sua vez notifica o **Netpoller**.
  8. O Netpoller encontra a goroutine G1 que estava esperando e a marca como **pronta para executar** ("runnable").
  9. O Scheduler do Go irá eventualmente escalar G1 para rodar em uma thread (M) livre, e a operação `Read()` será completada, agora sem bloqueio.

-------------------------------------
  STATUS DE UM FD (FLAGS DO EPOLL)
-------------------------------------
- Ao monitorar um FD, o Kernel usa flags para descrever seu estado:
  * `EPOLLIN`: **Pronto para Leitura**. Há dados disponíveis.
  * `EPOLLOUT`: **Pronto para Escrita**. O buffer de escrita tem espaço, a operação não bloqueará.
  * `EPOLLERR`: Ocorreu um erro no FD.
  * `EPOLLHUP`: "Hang-up". A outra ponta da conexão (ex: um cliente) desligou.
  * `EPOLLET`: "Edge-Triggered". Um modo de notificação que avisa apenas sobre *mudanças* de estado (de não-pronto para pronto).

-------------------------------------
  GO x NODE.JS (LIBUV)
-------------------------------------
- O Node.js alcança sua famosa performance de I/O usando exatamente o mesmo princípio.
- A biblioteca **libuv** é o coração do I/O assíncrono do Node.js.
- Assim como o Netpoller do Go, a `libuv` é uma camada de abstração multiplataforma sobre `epoll`, `kqueue`, `IOCP`, etc.
- A GRANDE SIMILARIDADE: Ambos os runtimes (Go e Node.js) usam um "reator de eventos" para delegar o trabalho de I/O ao Kernel e evitar o bloqueio de threads, permitindo alta concorrência. A diferença está no modelo de programação apresentado ao desenvolvedor (goroutines e channels em Go vs. callbacks e Promises no Node.js).

-------------------------------------
  DICAS RÁPIDAS
-------------------------------------
✅ File Descriptor (FD): Um número inteiro que é o "apelido" para um recurso de I/O no Kernel.
✅ `epoll`/`kqueue`: Ferramentas do SO para monitorar muitos FDs de uma só vez com alta performance.
✅ Netpoller: O componente do Go Runtime que usa `epoll`/`kqueue` para fazer I/O não-bloqueante.
✅ A "mágica" do Go: Quando uma goroutine faz I/O, ela "dorme", liberando sua thread para que o programa continue produtivo. O Netpoller a acorda quando o I/O está pronto.
✅ Go (Netpoller) e Node.js (libuv) são "irmãos de espírito": ambos usam os mesmos mecanismos do SO para alcançar a concorrência de I/O.