=====================================
  CHANNELS: O CORAÇÃO DA CONCORRÊNCIA EM GO
=====================================
- Channels são a principal ferramenta do Go para comunicação e sincronização entre goroutines. Eles fornecem uma maneira segura de transferir dados, evitando a causa mais comum de bugs em programas concorrentes: as "Data Races".

-------------------------------------
  O PROBLEMA: DATA RACES E A SOLUÇÃO TRADICIONAL (MUTEX)
-------------------------------------
- DATA RACE: Ocorre quando múltiplas goroutines acessam o mesmo local da memória simultaneamente, e pelo menos uma delas está escrevendo. O resultado é imprevisível e pode corromper os dados.

- SOLUÇÃO TRADICIONAL (MUTEX): A maioria das linguagens usa travas (`Mutex`, de *Mutual Exclusion*). Uma goroutine "trava" (`Lock`) o acesso à memória, faz sua modificação e depois "destrava" (`Unlock`).
  - DESVANTAGEM: É um processo manual e propenso a erros. O erro mais comum é o **Deadlock**, que acontece quando goroutines ficam presas, cada uma esperando que a outra libere uma trava que nunca será liberada.

-------------------------------------
  A FILOSOFIA DO GO: COMUNICAR PARA COMPARTILHAR
-------------------------------------
- Go propõe uma abordagem diferente, encapsulada na famosa frase de Rob Pike:
  > "Do not communicate by sharing memory; instead, share memory by communicating."
  > (Não se comunique compartilhando memória; em vez disso, compartilhe memória se comunicando.)

- A ideia é que, em vez de goroutines disputarem o acesso a uma variável compartilhada, elas devem passar a posse do dado de uma para a outra através de um canal. Apenas uma goroutine "possui" o dado por vez, eliminando a disputa por design.

-------------------------------------
  COMO OS CHANNELS FUNCIONAM? (A MECÂNICA)
-------------------------------------
- Um channel é um "cano" tipado através do qual você pode enviar e receber valores.

  // Criando channels
  chSemBuffer := make(chan int)
  chComBuffer := make(chan string, 10) // Buffer de tamanho 10

  // Enviando um valor para o canal (operação de escrita)
  chSemBuffer <- 42

  // Recebendo um valor do canal (operação de leitura)
  valor := <-chSemBuffer

  // Fechando um canal (sinaliza que não haverá mais envios)
  close(chComBuffer)

  // Verificando se um canal está aberto ao receber
  valor, ok := <-chComBuffer // Se 'ok' for false, o canal está fechado e vazio.

-------------------------------------
  TIPO 1: CANAIS SEM BUFFER (SINCRONIZAÇÃO)
-------------------------------------
- Também conhecidos como canais síncronos.
- COMPORTAMENTO: A comunicação só acontece quando o emissor e o receptor estão prontos ao mesmo tempo. É um "encontro marcado".
  * Um envio (`channel <- ...`) irá **BLOQUEAR** a goroutine até que outra goroutine esteja pronta para receber.
  * Um recebimento (`<- channel`) irá **BLOQUEAR** a goroutine até que outra goroutine esteja pronta para enviar.
- CASO DE USO: Sincronização direta. Garante que uma operação só continue depois que outra goroutine tenha recebido a "mensagem" ou o "sinal".

// EXEMPLO PRÁTICO (SEM BUFFER)
package main
import ("fmt"; "time")

func main() {
    ch := make(chan string)

    go func() {
        fmt.Println("Goroutine: Preparando para enviar...")
        time.Sleep(2 * time.Second)
        ch <- "Olá, Main!" // Bloqueia aqui até a main receber
        fmt.Println("Goroutine: Mensagem enviada!")
    }()

    fmt.Println("Main: Esperando por mensagem...")
    mensagem := <-ch // Bloqueia aqui até a goroutine enviar
    fmt.Printf("Main: Mensagem recebida: '%s'\n", mensagem)
}


-------------------------------------
  TIPO 2: CANAIS COM BUFFER (FILA/ASSINCRONIA)
-------------------------------------
- Também conhecidos como canais assíncronos. Funcionam como uma fila (FIFO - First-In, First-Out).
- COMPORTAMENTO: A comunicação é desacoplada.
  * Um envio (`channel <- ...`) só irá **BLOQUEAR** se o buffer estiver **CHEIO**.
  * Um recebimento (`<- channel`) só irá **BLOQUEAR** se o buffer estiver **VAZIO**.
- CASO DE USO: Distribuição de trabalho, gerenciamento de "rajadas" de dados. Permite que um produtor e um consumidor trabalhem em ritmos diferentes.

// EXEMPLO PRÁTICO (COM BUFFER)
package main
import ("fmt"; "time")

func main() {
    // Canal com buffer para 3 mensagens
    ch := make(chan int, 3)

    // O emissor envia 3 mensagens rapidamente sem bloquear
    fmt.Println("Enviando 1...")
    ch <- 1
    fmt.Println("Enviando 2...")
    ch <- 2
    fmt.Println("Enviando 3...")
    ch <- 3
    fmt.Println("Todos os 3 valores enviados para o buffer.")

    // O receptor consome os valores lentamente
    time.Sleep(2 * time.Second)
    fmt.Println("Recebido:", <-ch)
    time.Sleep(1 * time.Second)
    fmt.Println("Recebido:", <-ch)
    time.Sleep(1 * time.Second)
    fmt.Println("Recebido:", <-ch)
}

-------------------------------------
  PONTO DE ATENÇÃO: DEADLOCKS COM CHANNELS
-------------------------------------
- Channels também podem causar deadlocks. O erro mais comum é quando uma goroutine espera por uma operação em um canal que nunca acontecerá.
- Exemplo: `func main() { ch := make(chan int); <-ch }`
- Este código irá parar e o Go Runtime irá encerrá-lo com um erro de pânico, pois a goroutine principal está bloqueada esperando para receber de um canal para o qual nenhuma outra goroutine jamais enviará um valor.

-------------------------------------
  GO x NODE.JS (COMPARAÇÃO)
-------------------------------------
- JAVASCRIPT: Não possui um conceito nativo de "channels" no mesmo nível do Go. A comunicação entre contextos concorrentes (como entre a thread principal e um **Web Worker**, ou entre **worker_threads** no Node.js) é feita através de um sistema de passagem de mensagens com `postMessage()` e listeners de eventos (`onmessage`).
- A FILOSOFIA É PARECIDA: Ambos evitam o acesso direto à memória compartilhada em favor da comunicação por cópia de dados.
- A DIFERENÇA: Em Go, os channels são uma primitiva da linguagem, profundamente integrados com a sintaxe (`<-`), o scheduler e a instrução `select`, tornando-os mais poderosos e centrais para o modelo de concorrência.

-------------------------------------
  DICAS RÁPIDAS
-------------------------------------
✅ Channels = Comunicação segura entre goroutines.
✅ A filosofia: "Compartilhe memória se comunicando", não "se comunique compartilhando memória".
✅ Canal sem buffer (`make(chan T)`): Síncrono. Bloqueia até que ambos os lados estejam prontos.
✅ Canal com buffer (`make(chan T, N)`): Assíncrono. Bloqueia apenas se o buffer estiver cheio (envio) ou vazio (recebimento).
✅ Cuidado com deadlocks: Não espere por uma mensagem que nunca chegará.