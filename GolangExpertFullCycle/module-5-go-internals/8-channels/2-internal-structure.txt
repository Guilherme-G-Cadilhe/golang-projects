=====================================
  CHANNELS: ESTRUTURA INTERNA E DINÂMICA
=====================================
- Por baixo dos panos, um channel em Go é uma struct chamada `hchan`. Essa struct contém todas as informações necessárias para gerenciar o buffer, as goroutines em espera e o estado do canal, tudo de forma segura para concorrência.

-------------------------------------
  A STRUCT POR TRÁS DO CHANNEL (HCHAN)
-------------------------------------
- Os campos da struct `hchan` podem ser agrupados logicamente:

  // --- Configuração do Buffer (a fila de dados) ---
  * qcount:     O número ATUAL de elementos na fila.
  * dataqsiz:   A capacidade MÁXIMA do buffer (o 'q' de queue/fila). Para canais sem buffer, é 0.
  * buf:        Um ponteiro para o array que armazena os dados. Funciona como um BUFFER CIRCULAR.
  * elemsize:   O tamanho em bytes de cada elemento que o canal transporta.
  * sendx:      O próximo índice onde um DADO será ESCRITO no buffer.
  * recvx:      O próximo índice de onde um DADO será LIDO do buffer.

  // --- Estado e Sincronização ---
  * closed:     Uma flag (0 ou 1) que indica se o canal foi fechado.
  * lock:       Um MUTEX que protege todos os campos da struct, garantindo que apenas uma operação (envio/recebimento/fechamento) ocorra por vez.

  // --- Filas de Espera (o "estacionamento" de goroutines) ---
  * recvq:      Uma lista de goroutines que estão BLOQUEADAS esperando para RECEBER dados.
  * sendq:      Uma lista de goroutines que estão BLOQUEADAS esperando para ENVIAR dados.

- O BUFFER CIRCULAR:
  - `sendx` e `recvx` são ponteiros que se movem pelo buffer. Quando chegam ao fim, eles "dão a volta" para o início. Isso evita a necessidade de mover os elementos da fila, tornando a operação muito eficiente.
  - Ex: [ | | |v| | ] <- recvx
  - Ex: [ | | | |v| ] <- sendx

-------------------------------------
  A DINÂMICA DE UMA OPERAÇÃO DE ENVIO (SEND: ch <- data)
-------------------------------------
- O fluxo lógico que uma goroutine (G1) segue para enviar um dado é:

  1. ADQUIRIR O LOCK: G1 trava o mutex do canal para garantir acesso exclusivo.
  2. PROCURAR UM RECEPTOR: Existe alguma goroutine na fila de espera `recvq`?
     * SIM (Canal sem buffer ou buffer vazio com receptor esperando): O dado é copiado diretamente para a stack da goroutine receptora. A goroutine receptora é "acordada" e colocada na fila de execução do scheduler. A operação termina.
     * NÃO: Prossiga para o próximo passo.
  3. VERIFICAR O BUFFER: O buffer tem espaço? (`qcount < dataqsiz`)
     * SIM: O dado é copiado para a posição `buf[sendx]`. O índice `sendx` é incrementado. `qcount` é incrementado. A operação termina.
     * NÃO (Buffer está cheio): A G1 é "empacotada" com o dado que quer enviar e adicionada à fila `sendq`. A G1 é então BLOQUEADA (colocada para dormir).
  4. LIBERAR O LOCK: O lock é liberado.

-------------------------------------
  A DINÂMICA DE UMA OPERAÇÃO DE RECEBIMENTO (RECEIVE: data := <-ch)
-------------------------------------
- O fluxo para uma goroutine (G2) receber um dado é simétrico ao de envio:

  1. ADQUIRIR O LOCK.
  2. PROCURAR UM EMISSOR: Existe alguma goroutine na fila de espera `sendq`?
     * SIM (Buffer estava cheio): O dado é copiado do buffer. A goroutine emissora é "acordada" e seu dado é colocado no lugar do que foi retirado. A operação termina.
     * NÃO: Prossiga.
  3. VERIFICAR O BUFFER: O buffer tem dados? (`qcount > 0`)
     * SIM: O dado da posição `buf[recvx]` é copiado para G2. O índice `recvx` é incrementado. `qcount` é decrementado. A operação termina.
     * NÃO (Buffer está vazio): A G2 é adicionada à fila `recvq` e é BLOQUEADA.
  4. LIBERAR O LOCK.

-------------------------------------
  A DINÂMICA DE UMA OPERAÇÃO DE FECHAMENTO (CLOSE: close(ch))
-------------------------------------
- O fluxo para uma goroutine (G3) fechar o canal é:

  1. ADQUIRIR O LOCK.
  2. ATUALIZAR O ESTADO: A flag `closed` da struct é marcada como 1.
  3. NOTIFICAR TODO MUNDO: O runtime "acorda" TODAS as goroutines que estavam esperando nas filas `recvq` e `sendq`.
     * RECEPTORAS (`recvq`): Serão desbloqueadas e receberão o valor "zero" do tipo do canal (ex: 0 para `int`, "" para `string`).
     * EMISSORAS (`sendq`): Serão desbloqueadas e entrarão em pânico, pois é proibido enviar dados para um canal fechado.
  4. LIBERAR O LOCK.

-------------------------------------
  GO x NODE.JS (COMPARAÇÃO)
-------------------------------------
- Este nível de detalhe é altamente específico do Go. Em JavaScript, a mecânica interna da passagem de mensagens entre Web Workers ou a fila de eventos do Event Loop é uma abstração gerenciada pelo motor V8 ou pelo ambiente do navegador.
- Embora eles também usem estruturas de dados como filas e mecanismos de sincronização internamente, esses detalhes não são expostos ao desenvolvedor. A beleza do Go é que, embora o `hchan` seja interno, seu comportamento (bloqueio, buffer) é uma parte explícita e fundamental do modelo de concorrência que o programador utiliza diretamente.

-------------------------------------
  DICAS RÁPIDAS
-------------------------------------
✅ Todo channel é uma struct `hchan` protegida por um mutex.
✅ A performance vem do buffer circular e da otimização de passar dados diretamente se houver um receptor/emissor esperando.
✅ `sendq` e `recvq` são os "estacionamentos" onde as goroutines bloqueadas esperam.
✅ Enviar em um canal com buffer cheio bloqueia e adiciona a goroutine à `sendq`.
✅ Receber de um canal com buffer vazio bloqueia e adiciona a goroutine à `recvq`.
✅ `close(ch)` acorda todas as goroutines que estão esperando no canal.