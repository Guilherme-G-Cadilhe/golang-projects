=====================================
  QUANDO USAR CHANNELS SEM BUFFER (SÍNCRONOS)
=====================================
- Um channel sem buffer (`make(chan int)`) é a ferramenta fundamental do Go para sincronização. Ele força o produtor e o consumidor a se encontrarem no tempo e no espaço, garantindo que uma transferência de dados ocorra.

-------------------------------------
  O PRINCÍPIO FUNDAMENTAL: GARANTIA E SINCRONIZAÇÃO
-------------------------------------
- A principal razão para usar um channel sem buffer é **garantir** que uma goroutine não prossiga até que outra esteja em um ponto específico.
- ANALOGIA DA CORRIDA DE REVEZAMENTO:
  * O canal é a passagem do bastão. O primeiro corredor (Produtor) **deve parar e esperar** até que o segundo corredor (Consumidor) chegue e pegue o bastão fisicamente.
  * A entrega é a garantia de que ambos os corredores se encontraram e sincronizaram. A corrida do primeiro só termina quando a do segundo começa.

-------------------------------------
  CENÁRIOS DE USO IDEAIS
-------------------------------------

1. SINCRONIZAÇÃO ESTRITA E "HANDSHAKES" (APERTO DE MÃO)
   - Quando você precisa da certeza de que uma mensagem foi recebida antes de continuar. É um sinal de confirmação.
   - EXEMPLO: Garantir que um serviço ou recurso foi inicializado antes que o resto da aplicação comece a usá-lo. A goroutine principal espera por um "sinal verde".

// EXEMPLO PRÁTICO (HANDSHAKE)
package main
import ("fmt"; "time")

func initializeSystem(ready chan<- bool) {
    fmt.Println("Inicializando subsistemas...")
    time.Sleep(2 * time.Second) // Simula trabalho de inicialização
    fmt.Println("...sistemas prontos!")
    ready <- true // Envia o "sinal verde". Bloqueia até a main receber.
}

func main() {
    readyChan := make(chan bool)
    go initializeSystem(readyChan)

    // Bloqueia aqui, esperando o "sinal verde" da goroutine de inicialização.
    <-readyChan

    fmt.Println("Sinal recebido! Sistema pronto para operar.")
}

-------------------------------------
2. EVENTOS TEMPORIZADOS (TIMEOUTS) COM `select`
   - O `select` é como um `switch` para canais. Ele espera por múltiplas operações em canais e executa o caso do primeiro canal que ficar "pronto" (seja para envio ou recebimento).
   - Combinado com `time.After`, que retorna um canal que recebe um valor após uma duração, o `select` cria um padrão de timeout elegante.

// EXEMPLO PRÁTICO (TIMEOUT)
package main
import ("fmt"; "time")

func externalCall(result chan<- string) {
    // Simula uma chamada de API que pode ser lenta
    time.Sleep(3 * time.Second)
    result <- "Dados recebidos com sucesso!"
}

func main() {
    resultChan := make(chan string)
    go externalCall(resultChan)

    fmt.Println("Aguardando chamada externa por até 2 segundos...")

    select {
    case res := <-resultChan:
        fmt.Println("Recebido:", res)
    case <-time.After(2 * time.Second): // Este canal será "pronto" após 2s
        fmt.Println("Erro: Timeout! A operação demorou demais.")
    }
}

-------------------------------------
3. COORDENAR FINALIZAÇÃO (CHANNEL vs. WAITGROUP)
   - Você pode usar um canal sem buffer para esperar que uma ou mais goroutines terminem seu trabalho. A goroutine principal espera receber um "sinal de concluído" de cada worker.
   - PONTO IMPORTANTE: Para o caso específico de esperar por um grupo de N goroutines, a ferramenta mais idiomática e eficiente é o `sync.WaitGroup`. Ele foi projetado exatamente para isso.

// Exemplo com Channel:
// func main() {
//     done := make(chan bool)
//     go worker(done)
//     <-done // Espera pelo sinal
// }

// Exemplo idiomático com WaitGroup:
// func main() {
//     var wg sync.WaitGroup
//     wg.Add(1)
//     go worker(&wg)
//     wg.Wait() // Espera pelo sinal
// }
// func worker(wg *sync.WaitGroup) {
//     defer wg.Done()
//     // ... faz o trabalho ...
// }

-------------------------------------
  GO x NODE.JS (COMPARAÇÃO)
-------------------------------------
- O modelo de sincronização do JavaScript é baseado em `Promises` e `async/await`. Os conceitos são análogos:
  * **`<-ch` (Go):** É conceitualmente similar a usar `await` em uma `Promise` em JS. Em ambos os casos, a função "pausa" sua execução de forma não-bloqueante e espera que um resultado (ou sinal) esteja pronto antes de continuar.
  * **`select` (Go):** É muito parecido com `Promise.race()` em JS. Ambos permitem que você espere por múltiplos eventos assíncronos (ex: uma resposta de rede vs. um timeout) e reaja ao primeiro que acontecer.

-------------------------------------
  DICAS RÁPIDAS
-------------------------------------
✅ Use channel sem buffer para **garantir a sincronização**.
✅ Pense nele como um "encontro marcado" ou uma "passagem de bastão".
✅ É a ferramenta perfeita para "handshakes" (sinalização e confirmação).
✅ Em conjunto com `select` e `time.After`, cria um padrão de timeout poderoso e idiomático.
✅ Para apenas esperar N goroutines terminarem, `sync.WaitGroup` é geralmente a melhor escolha.