=====================================
  OTIMIZANDO O GC: GOGC E GCTRACE
=====================================
- Além de entender como o GC funciona, o Go nos dá ferramentas para controlar sua frequência e observar seu comportamento em detalhes, permitindo otimizações de performance.

-------------------------------------
  CONTROLANDO A FREQUÊNCIA: GOGC
-------------------------------------
- `GOGC` é uma variável de ambiente que controla a agressividade do Garbage Collector.
- FUNÇÃO: Define o percentual de crescimento da heap que irá acionar o próximo ciclo de GC.
- VALOR PADRÃO: `100`, o que significa `100%`.

- COMO FUNCIONA: O próximo GC será acionado quando o tamanho da heap atual atingir o tamanho da heap "viva" após o último GC, mais o percentual definido pelo `GOGC`.
  - FÓRMULA: `Próximo GC = HeapViva * (1 + GOGC/100)`
  - EXEMPLO PRÁTICO: Se após um ciclo de GC a memória viva (heap que contém objetos em uso) é de 4MB e `GOGC=100`, o próximo GC será acionado quando o tamanho total da heap atingir `4MB * (1 + 100/100) = 8MB`.

- O TRADE-OFF (A ESCOLHA):
  * `GOGC` baixo (ex: `GOGC=50`):
    - PRÓ: Usa menos memória total.
    - CONTRA: O GC é acionado com mais frequência, consumindo mais CPU e causando mais pausas (STW), o que pode diminuir a performance da aplicação.
  * `GOGC` alto (ex: `GOGC=200`):
    - PRÓ: O GC é acionado com menos frequência, resultando em menos tempo de CPU gasto com GC e menos pausas.
    - CONTRA: Permite que a heap cresça muito mais, aumentando o consumo de memória do programa.

- COMO CONFIGURAR:
  `GOGC=50 go run main.go`

-------------------------------------
  OBSERVANDO O GC EM AÇÃO: GCTRACE
-------------------------------------
- `gctrace` é uma flag da variável de ambiente `GODEBUG` que instrui o runtime a imprimir um resumo detalhado de cada ciclo de GC.
- COMO USAR:
  `GODEBUG=gctrace=1 go run main.go`
  - A flag `=1` ativa o trace. A saída é impressa no `stderr`.

-------------------------------------
  ANATOMIA DE UM LOG DO GCTRACE
-------------------------------------
- Vamos dissecar uma linha de log típica, campo por campo:
  `gc 1 @0.019s 0%: 0.014+0.56+0.010 ms clock, 0.029+0/0.55/0+0.021 ms cpu, 4->4->1 MB, 5 MB goal, 8 P`

  * `gc 1`: O número de identificação do ciclo de GC. Este foi o 1º ciclo.
  * `@0.019s`: O tempo, em segundos, desde o início do programa até o FIM deste ciclo de GC.
  * `0%`: A porcentagem de tempo que a aplicação passou com o "mundo parado" (STW) desde o início do programa. Este é um indicador chave da performance do GC.
  * `0.014+0.56+0.010 ms clock`: O tempo de "relógio de parede" (wall-clock) gasto nas fases do GC.
    - `0.014ms`: Duração da pausa STW inicial (Mark Setup).
    - `0.56ms`: Duração da fase de marcação concorrente (Marking).
    - `0.010ms`: Duração da pausa STW final (Mark Termination).
  * `0.029+0/0.55/0+0.021 ms cpu`: O tempo de CPU gasto pelo GC. É mais complexo, mas representa o tempo de CPU para: STW Setup + Marking Concorrente (assistido/dedicado/ocioso) + STW Termination.
  * `4->4->1 MB`: A progressão do tamanho da heap.
    - `4MB`: Tamanho da heap no início do ciclo.
    - `->4MB`: Tamanho da heap no final do ciclo (pode ter crescido durante a marcação).
    - `->1MB`: Tamanho da heap "viva" (objetos alcançáveis) após a limpeza. Este é o número usado para calcular o próximo `goal`.
  * `5 MB goal`: O tamanho da heap que ATIVOU o ciclo de GC atual. O `goal` para o próximo ciclo será calculado com base na heap viva (`1MB`). Com `GOGC=100`, o próximo `goal` será `2MB`.
  * `8 P`: O número de processadores lógicos (P's) utilizados (`GOMAXPROCS`).

-------------------------------------
  INTERPRETANDO OS NÚMEROS NA PRÁTICA
-------------------------------------
- O QUE PROCURAR EM UM LOG DE GCTRACE:
  * TEMPOS DE PAUSA (STW): Os valores primeiro e terceiro no `clock` (ex: `0.014` e `0.010`). Se eles começarem a ficar muito altos (vários ms), podem impactar a latência da sua aplicação.
  * PORCENTAGEM DE GC (`%`): Se este número começar a crescer (ex: 5%, 10%), significa que sua aplicação está gastando uma quantidade significativa de tempo parada, esperando o GC.
  * HEAP VIVA (`->1MB`): Observe como a memória viva se comporta. Se ela cresce continuamente a cada ciclo e nunca diminui, você pode ter um memory leak.

-------------------------------------
  DICAS RÁPIDAS
-------------------------------------
✅ `GOGC=100`: Padrão. Aciona o GC quando a heap dobra de tamanho em relação à memória viva anterior.
✅ Baixar o `GOGC` economiza memória, mas custa mais CPU. Aumentar faz o oposto.
✅ `GODEBUG=gctrace=1`: Seu "eletrocardiograma" para a saúde do gerenciamento de memória.
✅ No `gctrace`, foque na `%` de tempo em GC e nos tempos de pausa (STW) para diagnosticar problemas de performance.
✅ O crescimento constante da "heap viva" (o último número em MB) é um forte indicador de memory leak.