=====================================
  GERENCIAMENTO DE MEMÓRIA: FRAGMENTAÇÃO E ALOCADORES
=====================================
- Quando seu programa pede memória (para criar variáveis, objetos, etc.), não é o SO que responde a cada pedido. Existe uma camada intermediária chamada "Alocador de Memória" que gerencia isso de forma eficiente.

-------------------------------------
  O PROBLEMA: FRAGMENTAÇÃO DE MEMÓRIA
-------------------------------------
- A fragmentação é o principal desafio que um alocador de memória tenta resolver. Ela ocorre quando a memória livre é dividida em muitos pedaços pequenos, tornando-se inutilizável.

  1) FRAGMENTAÇÃO EXTERNA:
     - Ocorre quando existem blocos de memória livre suficientes para atender a um pedido, mas eles NÃO SÃO CONTÍGUOS (não estão um do lado do outro).
     - Exemplo: Você tem 10MB de memória livre, mas divididos em blocos de 1MB. Se o programa pedir um bloco único de 2MB, a alocação falhará.
     - há vários blocos vazios, mas não há espaço para alocar 3 blocos juntos.

  2) FRAGMENTAÇÃO INTERNA:
     - Ocorre quando um bloco de memória alocado é MAIOR do que o necessário. O espaço que sobra dentro do bloco é desperdiçado.
     - Exemplo: O alocador trabalha com blocos de 8 bytes. Se você pede para alocar 5 bytes, ele te dá um bloco de 8, desperdiçando 3 bytes.

-------------------------------------
  A ESTRATÉGIA: MEMORY ARENAS
-------------------------------------
- Em vez de pedir pequenos pedaços de memória ao SO toda hora (uma operação lenta), o alocador usa a estratégia de "Arenas".
- O QUE É UMA ARENA?: É um grande bloco de memória contíguo que o alocador pede ao SO de uma só vez (ex: 64MB).
- COMO FUNCIONA?: O alocador se torna o "dono" dessa arena e a gerencia internamente, fatiando-a em pedaços menores (chunks) para atender aos pedidos do seu programa.
- VANTAGEM: Reduz drasticamente o número de chamadas de sistema (operações lentas) e dá ao alocador total controle para otimizar a gestão daquele espaço.

-------------------------------------
  ORGANIZANDO A ARENA: CHUNKS E BINS
-------------------------------------
- Dentro de uma Arena, a memória é dividida e organizada para ser encontrada rapidamente.

  * CHUNKS (PEDAÇOS): A Arena é dividida em "chunks", que são as unidades básicas de alocação. Cada chunk tem um pequeno cabeçalho (metadata) que informa seu tamanho e se está livre ou em uso.

  * BINS (CESTOS): Para encontrar um chunk livre do tamanho certo rapidamente, o alocador os agrupa em listas chamadas "bins". Cada bin contém chunks de um tamanho específico ou de uma faixa de tamanho.
    - Fast Bins: Para objetos muito pequenos e de alocação/liberação muito frequente.
    - Small Bins: Para objetos pequenos.
    - Large Bins: Para objetos grandes.

- Esse sistema de organização (Arenas -> Chunks -> Bins) permite que o alocador encontre um bloco de memória adequado para seu pedido de forma extremamente rápida.

-------------------------------------
  ALOCADORES DE MEMÓRIA POPULARES (MUNDO C)
-------------------------------------
- A lógica de alocação evoluiu ao longo do tempo, principalmente para lidar com concorrência (multithreading).

  * malloc/free: A interface padrão da biblioteca C. A implementação pode variar.
  * dlmalloc: Um dos primeiros alocadores de propósito geral. Muito eficiente, mas usa um "lock" global, o que o torna um gargalo em sistemas multithreaded.
  * ptmalloc2: O padrão na maioria dos sistemas Linux (glibc). A grande inovação foi o uso de ARENAS POR THREAD/CORE. Cada thread tem sua própria arena, eliminando a disputa pelo lock global e melhorando drasticamente a performance em aplicações concorrentes.
  * jemalloc (Facebook): Focado em reduzir a fragmentação e escalar de forma eficiente com um número muito grande de núcleos. Usado pelo FreeBSD, Rust, Firefox.
  * TCMalloc (Google): Thread-Caching Malloc. Leva a ideia do ptmalloc adiante, mantendo um cache de memória por thread para objetos pequenos, tornando as alocações/liberações extremamente rápidas.

-------------------------------------
  O ALOCADOR DE MEMÓRIA DO GO (INSPIRADO NO TCMALLOC)
-------------------------------------
- Go NÃO USA o `malloc` do sistema. Ele tem seu próprio alocador de memória, escrito em Go e otimizado para as características da linguagem.
- FORTE INSPIRAÇÃO: O alocador do Go é fortemente inspirado no TCMalloc do Google.
- COMO FUNCIONA:
  1. Go pega grandes regiões de memória do SO (as **Arenas**).
  2. Essas arenas são divididas em **spans** (blocos de 8KB, similar aos chunks).
  3. Cada **P** (Processador Lógico do Go) possui um cache local de spans, chamado **mcache**.
  4. Quando uma goroutine precisa de um objeto pequeno, ela o aloca diretamente do `mcache` do seu `P`, SEM precisar de locks.
- RESULTADO: A alocação de objetos pequenos em Go é incrivelmente rápida e eficiente em ambientes com alta concorrência, pois a disputa por travas (locks) é quase eliminada.

-------------------------------------
  GO x NODE.JS (COMPARAÇÃO)
-------------------------------------
- O motor V8 do Node.js também possui seu próprio gerenciador de memória sofisticado, com um Garbage Collector geracional. Os princípios são os mesmos: ele pega memória do SO em blocos grandes e os gerencia internamente para otimizar a performance. A principal diferença está na forma como as otimizações são focadas (o Go é otimizado para a concorrência massiva do modelo G-M-P).

-------------------------------------
  DICAS RÁPIDAS
-------------------------------------
✅ Fragmentação: Memória livre existe, mas está em pedaços inúteis.
✅ Arena: Um "latifúndio" de memória que o alocador pega do SO para gerenciar por conta própria.
✅ Chunks e Bins: A forma como o alocador organiza os "lotes" (chunks) em "cestos" (bins) por tamanho para agilizar a busca.
✅ O alocador do Go é como o TCMalloc: cada P tem seu próprio "estoque" (mcache) de memória para alocações pequenas, tornando-as super rápidas e sem concorrência.