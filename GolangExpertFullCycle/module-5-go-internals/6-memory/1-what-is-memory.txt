=====================================
  MEMÓRIA: CONCEITOS BÁSICOS
=====================================
- A memória de um computador é organizada em camadas (hierarquia) baseada na velocidade de acesso versus o tamanho.

-------------------------------------
  A HIERARQUIA DE MEMÓRIA (VELOCIDADE vs. TAMANHO)
-------------------------------------

1) MEMÓRIA DE RÁPIDO ACESSO (CACHE DA CPU)
   - L1 Cache (~64 KB): Extremamente rápida, no mesmo chip do núcleo da CPU. Guarda as instruções/dados mais imediatos.
   - L2 Cache (~512 KB): Rápida, um pouco maior e mais lenta que a L1.
   - L3 Cache (~8-16 MB): "Lenta" para os padrões de cache, mas ainda muito mais rápida que a RAM. Compartilhada entre os núcleos da CPU.

2) MEMÓRIA DE ACESSO "LENTO" (RAM - MEMÓRIA PRINCIPAL)
   - Pentes de memória (DDR - Double Data Rate).
   - Conectada à CPU via um barramento na placa-mãe.
   - É onde os programas e seus dados são efetivamente carregados para execução. Muito maior que os caches, porém mais lenta.

-------------------------------------
  MEMÓRIA VIRTUAL: O TRUQUE DO ISOLAMENTO
-------------------------------------
- O SO dá a cada PROCESSO a ilusão de que ele tem todo o espaço de memória da máquina só para si.
- COMO FUNCIONA: O SO cria um mapeamento (usando "Page Tables") entre os endereços de memória "virtuais" que o seu programa usa e os endereços "físicos" reais na RAM.
- VANTAGENS:
  * ISOLAMENTO: Um processo não pode acessar a memória de outro. Se o Processo A tentar acessar um endereço do Processo B, o SO bloqueia a operação.
  * SEM COLISÃO: Dois processos podem usar o mesmo endereço de memória virtual (ex: `0x1234`), pois o SO mapeia cada um para um local físico diferente na RAM.


=====================================
  STACK vs. HEAP: A DIVISÃO FUNDAMENTAL
=====================================
- Dentro de um processo, a memória é organizada principalmente em duas áreas: a Stack e a Heap.

  CARACTERÍSTICA     | STACK (PILHA)                                | HEAP
-------------------------------------------------------------------------------------------------
  Propósito         | Alocação estática. Funções e variáveis locais. | Alocação dinâmica. Objetos e dados compartilhados.
  Velocidade        | MUITO RÁPIDA.                                  | MAIS LENTA.
  Alocação          | Automática. Apenas move um ponteiro.           | Controlada (pelo alocador e GC em Go).
  Estrutura         | LIFO (Last-In, First-Out). Organizada.       | Sem ordem específica. Potencialmente fragmentada.
  Tamanho           | Pequeno e fixo por thread/goroutine.         | Grande e flexível para todo o processo.
  Vida útil dos dados | Temporária. Só durante a execução da função.   | Longa. Até não serem mais referenciados (GC).
  Risco Principal   | Stack Overflow (estourar a pilha).           | Memory Leaks, Fragmentação, Sincronização.


-------------------------------------
  O HEAP EM DETALHES (PRÓS E CONTRAS)
-------------------------------------

  (+) VANTAGENS:
      * Flexibilidade: Permite alocação de memória de tamanho variável em tempo de execução.
      * Acessibilidade Global: Dados na Heap podem ser acessados por qualquer thread/goroutine do processo.
      * Suporta Estruturas Complexas: Ideal para listas, árvores, mapas e objetos grandes.

  (-) DESAFIOS:
      * Lentidão: Alocar e encontrar espaço na Heap é mais lento que empurrar um valor na Stack.
      * Vazamentos (Leaks): Se referências a objetos não são liberadas, o Garbage Collector não pode limpar a memória, que cresce indefinidamente.
      * Fragmentação: Com o tempo, o ciclo de alocar/desalocar pode criar "buracos" de memória não utilizados, dificultando alocações de blocos grandes.
      * Concorrência: Múltiplas threads/goroutines acessando o mesmo dado na Heap exigem sincronização (ex: Mutex) para evitar "Race Conditions".


-------------------------------------
  RELAÇÃO COM GO: ANÁLISE DE ESCAPE (ESCAPE ANALYSIS)
-------------------------------------
- Em Go, você NÃO decide explicitamente se uma variável vai para a Stack ou para a Heap. O COMPILADOR decide por você.
- O processo que faz isso é a "Análise de Escape".
- COMO FUNCIONA: O compilador analisa o código para ver se o endereço de uma variável "escapa" de seu escopo original.
  * NÃO ESCAPA: Uma variável usada apenas dentro de sua própria função. -> Alocada na STACK (rápido).
  * ESCAPA: O ponteiro de uma variável é retornado, ou a variável é usada em uma closure que sobrevive à função. -> Alocada na HEAP (necessário para que o dado continue existindo).
- Isso é uma otimização poderosa: Go tenta usar a Stack sempre que possível pela sua velocidade.


-------------------------------------
  GO x NODE.JS (COMPARAÇÃO)
-------------------------------------
- O modelo é muito similar. Ambas as linguagens possuem um Call Stack (para execução de funções) e uma Memory Heap (para objetos e dados).
- JAVASCRIPT: Praticamente todos os `objetos {}` e `arrays []` são alocados na HEAP. Variáveis primitivas (number, boolean) dentro de uma função geralmente ficam na STACK.
- GO: A Análise de Escape permite que até mesmo `structs` e `arrays` fiquem na STACK se for seguro, o que pode levar a um melhor desempenho em certos casos.


-------------------------------------
  DICAS RÁPIDAS
-------------------------------------
✅ Cache (L1-L3): Memória pequena e super rápida dentro da CPU.
✅ RAM: Memória grande e mais lenta fora da CPU.
✅ Memória Virtual: Abstração do SO que isola os processos.
✅ Stack: Rápida, organizada, automática, para dados locais de funções.
✅ Heap: Lenta, flexível, gerenciada, para dados que precisam persistir ou ser compartilhados.
✅ Go decide onde alocar (Stack ou Heap) via "Análise de Escape".